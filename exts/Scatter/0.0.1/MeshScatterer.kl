require Math;
require Geometry;
require FabricStatistics;
require Manipulation;

const UInt32 G_SCATTERER_RANDOMS = 5; // Number of random numbers are needed per generated point. 
const UInt32 G_SCATTERER_SEED = 1234; // The seed for the randoms. 


function Points.addScattererAttributes!() {
  GeometryAttributes attributes = this.getAttributes();
  GeometryLocationAttribute geolocations = attributes.getOrCreateGeometryLocationAttribute("emitLocation");
  ScalarAttribute sizes = this.getOrCreateSizesAttribute();
}


interface DartSizer;
interface DartFilterer;


object MeshScatterer : Persistable {
  Boolean initialized;
  Points points;
  SpatialQueryable pointsQueryable;

  PolygonMesh sourceMesh;
  Mat44 sourceMeshMat44;

  Boolean sourceMeshAreasInit; 

  Scalar sourceMeshArea; 
  Scalar sourceMeshPolyAreas[];  
  Scalar sourceMeshPolyCumulativeAreas[];  

  Weightmap weightmap;
  Scalar weightmap_persistData[];

  Scalar defaultSize;
  Scalar maxSize;

  Points dartCandidates;
  Boolean dartCandidatesRemove[];

  UInt32 dartsIterations;
  UInt32 dartsTried;

  DrawingHandle handle;
};

function MeshScatterer() {
  this.clearAndInitPoints();
}

function ~MeshScatterer() {
  this.handle = null;
}

function MeshScatterer(PolygonMesh sourceMesh, Mat44 sourceMeshMat44) {
  this.initMeshes(sourceMesh, sourceMeshMat44);
}


function MeshScatterer.initMeshes!(PolygonMesh sourceMesh, Mat44 sourceMeshMat44) {
  this.clearAndInitPoints();
  this.initialized = true;
  this.sourceMesh = sourceMesh;
  this.sourceMeshMat44 = sourceMeshMat44;
}


function MeshScatterer.clearAndInitPoints!() {
  this.points = Points();
  this.points.addScattererAttributes();
  this.pointsQueryable = this.points.prepareForSpatialQueries(1, null);

  this.sourceMeshAreasInit = false;
  
  this.defaultSize = 0.0f;
  this.maxSize = 0.0f;

  this.dartCandidates = Points();
  this.dartCandidates.addScattererAttributes();

  this.dartsTried = 0;
}


/*
    Settings initialization
*/

function MeshScatterer.setUniformSize!(Scalar radius) {
  this.defaultSize = radius;
  this.maxSize = radius;

  for ( UInt32 i=0; i<this.points.size(); i++) {
    this.points.setSize(i, radius);
  }
}

function MeshScatterer.setDefaultSize!(Scalar radius) {
  this.defaultSize = radius;
  this.maxSize = Math_max(this.defaultSize, this.maxSize);;
}


/*
    member access
*/

inline Points MeshScatterer.getPoints() {
  return this.points;
}


/*
    weight maps
*/

function MeshScatterer.weightmapInit!() {
  this.weightmap = Weightmap();
  this.weightmap.connect(this.sourceMesh, this.sourceMeshMat44);

  if (this.weightmap_persistData.size() > 0) {
    // initializing and there is already persistence data
    if (this.weightmap_persistData.size() == this.weightmap.weightMapAttr.values.size()) {
      this.weightmap.weightMapAttr.values = this.weightmap_persistData;
    }
  } else {
    // initializing and there is not already persistence data
    this.weightmap_persistData = this.weightmap.weightMapAttr.values;
  }
  this.weightmap.display(true);
}


function MeshScatterer.weightMapInitIfNeeded!() {
  if (!this.weightmap) {
    this.weightmapInit();
  }
}


function MeshScatterer.weightmapActivatePainting!(Boolean active) {
  this.weightMapInitIfNeeded();
  if (active)
    this.weightmap.activateManipulator();
  else
    this.weightmap.deactivateManipulator();  
}


/*
    Scatterer Helpers
*/


function MeshScatterer.measurePolygonAreas!() {
  this.sourceMeshAreasInit = true;
  
  PolygonMesh mesh = this.sourceMesh;

  UInt32 polyCount = mesh.polygonCount();
  this.sourceMeshPolyAreas.resize(polyCount);
  measurePolygonAreas<<<polyCount>>>(this.sourceMeshPolyAreas, mesh);
  makeCumulativeArray(this.sourceMeshPolyAreas, this.sourceMeshPolyCumulativeAreas);
  this.sourceMeshArea = this.sourceMeshPolyCumulativeAreas[polyCount - 1];
}

inline MeshScatterer.measurePolgyonsIfNeeded!() {
  if (!this.sourceMeshAreasInit) {
    this.measurePolygonAreas();
    
  }
}


/*
    Scatterer Proper
*/

function MeshScatterer.scatterCore!(Integer quantityIn, UInt32 seed, Boolean toCandidates) {
  AutoProfilingEvent p("Section_Making");
  this.measurePolgyonsIfNeeded();

  UInt32 quantity = 0;
  if (quantityIn > 0) {
    quantity = quantityIn;
  }

  Points pointCloud = null;
  if (toCandidates) {
    pointCloud = this.dartCandidates;    
    pointCloud.resize(quantity);    
  } else {
    pointCloud = this.points;
    pointCloud.resize(pointCloud.size() + quantity);
  }

  UInt32 selectedIndices[];
  selectedIndices.resize(quantity);

  getRandomPolygonsWeighted<<<quantity>>>(this.sourceMeshPolyCumulativeAreas, seed, selectedIndices );
  
  PerPolyScatterInfo info[];
  info.resize(this.sourceMesh.polygonCount());

  for(UInt32 i=0; i<quantity; i++) {
    UInt32 polyIndex = selectedIndices[i];
    info[polyIndex].pointsOnPoly++;
  }

  UInt32 startIndex = 0;
  
  for(UInt32 i=0; i<this.sourceMesh.polygonCount(); i++) {
    info[i].startIndex = startIndex;
    startIndex += info[i].pointsOnPoly;
  }

  scatterPointsOnPolygons<<<this.sourceMesh.polygonCount()>>>(
      this.sourceMesh, 
      this.sourceMeshMat44, 
      info, 
      seed, 
      this.defaultSize, 
      pointCloud);
}


function MeshScatterer.scatter!(UInt32 quantity, UInt32 seed) {
  this.scatterCore(quantity, seed, false);
}


/*
    DART THROWER 
*/

function MeshScatterer.dartScatterCandidates!(UInt32 quantity, UInt32 seed) {
  this.scatterCore(quantity, seed, true);
}

inline MeshScatterer.runDartSizer!(io DartSizer sizer, UInt32 iteration) {
  DartSizer currentSizer = sizer;
  currentSizer.setCandidateSizes(this.dartCandidates, this, iteration);

  for (UInt32 i = 0; i < this.dartCandidates.size(); i++ ) {
    if (this.dartCandidates.getSize(i) > this.maxSize) {
      this.maxSize = this.dartCandidates.getSize(i);
    }
  }
}

function DartSizer MeshScatterer.getDartSizer!(in DartSizer sizer, Scalar defaultSize) {
  DartSizer currentSizer = sizer;
  if (currentSizer == null) {
    currentSizer = constantDartSizer(defaultSize);
  } else {
    currentSizer = sizer;
  }
  return currentSizer;
}


/*
    DART THROWER - filter
*/

inline MeshScatterer.resetCandidateFilter!() {
  this.dartCandidatesRemove.resize(this.dartCandidates.size);
  for ( UInt32 i=0; i<this.dartCandidatesRemove.size(); i++) {
    this.dartCandidatesRemove[i] = false;
  }
}

function DartFilterer MeshScatterer.getDartFilterer(in DartFilterer filterer) {
  DartFilterer currentFilterer = filterer;
  if (filterer == null) {
    currentFilterer = defaultDartFilterer();
  }
  return currentFilterer;
}

inline MeshScatterer.runDartFilterer!(io DartFilterer filterer, UInt32 iteration) {
  DartFilterer currentFilterer = filterer;
  this.resetCandidateFilter();
  currentFilterer.filterCandidates(this, iteration);
}


/*
    DART THROWER - add filtered 
*/

function MeshScatterer.dartAddFilteredCandidates!( ) {
  AutoProfilingEvent p("Section_Adding");
  UInt32 newPointsCount = 0;
  for ( UInt32 i=0; i<this.dartCandidates.size(); i++) {
    if ( this.dartCandidatesRemove[i] == false) {
      newPointsCount++;
    }
  }

  GeometryLocationAttribute pointEmitLoc = this.points.getAttributes().getOrCreateGeometryLocationAttribute("emitLocation");
  GeometryLocationAttribute candidateEmitLoc =  this.dartCandidates.getAttributes().getOrCreateGeometryLocationAttribute("emitLocation");

  UInt32 firstNewPoint = this.points.addPoints(newPointsCount);
  UInt32 pointsAdded = 0;
  for ( UInt32 i=0; i<this.dartCandidates.size(); i++) {
    if ( this.dartCandidatesRemove[i] == false) {
      UInt32 newPointID = firstNewPoint + pointsAdded;
      pointsAdded++;

      this.points.setPosition(  newPointID, this.dartCandidates.getPosition(i));
      this.points.setSize(      newPointID, this.dartCandidates.getSize(i));

      pointEmitLoc.values[newPointID] = candidateEmitLoc.values[i];
    }
  }
}



/*
    DART THROWER - proper 
*/

function MeshScatterer.throwDarts!(
    in Integer quantityPerIteration, 
    in UInt32 iterations, 
    in UInt32 seed,
    in DartSizer sizer,
    in DartFilterer filterer ) { 
  this.dartsIterations = iterations;

  DartSizer currentSizer = this.getDartSizer(sizer, this.defaultSize);
  DartFilterer currentFilterer = this.getDartFilterer(filterer);

  Boolean autoQuantitiy = false;
  UInt32 quantity = quantityPerIteration;
  UInt32 randomOffset = seed;
  UInt32 attemptCount;

  if (quantityPerIteration < 0)
    autoQuantitiy = true;

  AutoProfilingEvent p("total");
  for (UInt32 i = 0; i < iterations; i++ ) {
    if (autoQuantitiy)
      quantity = this.estimateDartCount(currentSizer.estimateDartSize(this, i)); 
    randomOffset += quantity*5;
    attemptCount += quantity;
    this.dartScatterCandidates(quantity, randomOffset);
    this.runDartSizer(currentSizer, i);
    this.runDartFilterer(currentFilterer, i);
    this.dartAddFilteredCandidates();
  }
  report("Done dart throwing. " + this.points.size() + " points added in " + attemptCount + " attempts over " + iterations + " iterations.");
}



/*
    Dart Throwing Convenience functions
*/

function MeshScatterer.throwDarts!(
    in Integer quantityPerIteration, 
    in UInt32 iterations, 
    in UInt32 seed
    ) {
  this.throwDarts(quantityPerIteration, iterations, seed, null, null);
}


inline UInt32 MeshScatterer.estimateDartCount!(Scalar dartSize) {
  this.measurePolgyonsIfNeeded();
  Scalar area = this.sourceMeshArea;
  return (area / dartSize) / 60.0f;
}


/*
    Nuzzler
*/

function MeshScatterer.nuzzle!(UInt32 iterations, Boolean allowShrink, Scalar maxSizeFactor) {
  AutoProfilingEvent pe("nuzzle");
  UInt32 pointCount = this.points.size();
  GenericValueContainer options = GenericValueContainer();
  PrepareForSpatialQueries_setSparseGrid(options);
  this.pointsQueryable.prepareForSpatialQueries(pointCount, options);

  Scalar nuzzle[];
  nuzzle.resize(pointCount);
  Scalar maxNUzzling = this.maxSize*maxSizeFactor;
  for (UInt32 i = 0; i < iterations; i++) {

    nuzzleNeighbors<<<pointCount>>>(nuzzle, this.points, this.pointsQueryable, maxNUzzling);

    for (UInt32 p = 0; p < pointCount; p++) {
      Scalar nuzzleAmount = nuzzle[p];
      if (nuzzleAmount) {        
        Scalar pointSize = this.points.getSize(p);
        Scalar newSize = pointSize + nuzzle[p]/2.0f;
        this.maxSize = Math_max( this.maxSize, newSize);
        this.points.setSize(p, newSize);
      }
    }
  }
}


/*
    Persistence Data
*/

function MeshScatterer.persistence_prepareData?(io JSONDoc doc, String namespace) {
  String wmap_data_name = (namespace + "_weightmap_values");
  if (this.weightmap_persistData.size() > 0) {
    // means the previous iteration of the array has not been copied
    JSONArrayValue jArray();
    for (UInt32 i = 0; i < this.weightmap_persistData.size(); i++) {
      jArray.addScalar( this.weightmap_persistData[i] );
    }
    doc.root.set((namespace + "_weightmap_values"), jArray);
  }
}


function MeshScatterer.persistence_restoreData!(io JSONDoc doc, String namespace) {
  String wmap_data_name = (namespace + "_weightmap_values");
  if(doc.root.has(wmap_data_name)){
    JSONArrayValue jArray = doc.root.get(wmap_data_name);
    this.weightmap_persistData.resize(jArray.size());
    for (UInt32 i = 0; i < jArray.size(); i++) {
      this.weightmap_persistData[i] = jArray.getScalar(i);
    }
  }  
}


/*
    Persistence Proper
*/

function String MeshScatterer.saveDataToString?(PersistenceContext context) {
  report("Attempting Save!");
  JSONDoc doc();

  this.persistence_prepareData(doc, "");

  return doc.write();
}


function MeshScatterer.loadDataFromString!(PersistenceContext context, String data) {
  report("Attempting Unsave!");
  report(data);

  JSONDoc doc();
  Boolean parsed = doc.parse(data);
  
  if (!parsed) {
    setError("ERROR Loading persistence data. Saved JSON data is not valid");
    return;
  }

  this.persistence_restoreData(doc, "");
}
