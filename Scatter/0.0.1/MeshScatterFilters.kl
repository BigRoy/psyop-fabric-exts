

/*
    Filtering utilities
*/




operator filterDartsBySize<<<pointIndex>>>(io Boolean pointsDelete[], in Points candidatePoints, Ref<SpatialQueryable> filterQueryable, in Points filterPoints, in Scalar maxRadius) {
  /* 
    Sequence of early outs: 

    If this point is already filtered out, we're done. 

    If there are no points in the bounding radius, we're done. 
    If there is only one point, and we're filtering against ourselves, we're done. 

    If the distance of the point to any other < radius1 + radius2, delete & we're done, otherwise continue searching
  */
  if (pointsDelete[pointIndex]) {
    // If this point is already marked for deletion, we're done.
    return;
  }

  Scalar candidateSize = candidatePoints.getSize(pointIndex);
  Vec3 candidatePosition = candidatePoints.getPosition(pointIndex);

  Ref<SpatialQuery> query = filterQueryable.beginSpatialQuery();
  UInt32 elements = query.getElementsInBSphere(candidatePoints.getPosition(pointIndex), maxRadius + candidateSize);

  if (elements == 0){
    filterQueryable.endSpatialQuery(query);
    return;
  }

  if (candidatePoints === filterPoints) {
    if (elements == 1) {
      // found only self
      filterQueryable.endSpatialQuery(query);
      return;
    }    
  }

  for (UInt32 i = 0; i < elements; i++) {
    UInt32 iElement = query.getQueriedElement(i);

    Vec3 targetPosition = filterPoints.getPosition(iElement);
    Scalar targetSize = filterPoints.getSize(iElement);

    if (candidatePosition.distanceTo(targetPosition) < (targetSize + candidateSize)) {
      pointsDelete[pointIndex] = true;
      filterQueryable.endSpatialQuery(query);
      return;
    }
  }

  filterQueryable.endSpatialQuery(query);
  return;
}



/*
    Preset Dart Filterers
*/

interface DartFilterer {
  filterCandidates!(io Ref<MeshScatterer> scatterer, UInt32 iteration);
};


object defaultDartFilterer : DartFilterer {
};

function defaultDartFilterer.filterCandidates!(io Ref<MeshScatterer> scatterer, UInt32 iteration) {
  AutoProfilingEvent p("Section_Filtering");
  SpatialQueryable candidatesQueryable = null;
  {    
    AutoProfilingEvent pe("buildAccells");
    GenericValueContainer options = GenericValueContainer();
    PrepareForSpatialQueries_setSparseGrid(options);

    candidatesQueryable = scatterer.dartCandidates.prepareForSpatialQueries(scatterer.dartCandidates.size(), options);
    scatterer.pointsQueryable.prepareForSpatialQueries(scatterer.dartCandidates.size(), options);
  }


  {
    AutoProfilingEvent pe("filter self");
    filterDartsBySize<<<scatterer.dartCandidates.size()>>>(scatterer.dartCandidatesRemove, scatterer.dartCandidates, candidatesQueryable, scatterer.dartCandidates, scatterer.maxSize);
  }

  {
    AutoProfilingEvent pe("filter points");
    filterDartsBySize<<<scatterer.dartCandidates.size()>>>(scatterer.dartCandidatesRemove, scatterer.dartCandidates, scatterer.pointsQueryable, scatterer.points, scatterer.maxSize);
  }

  candidatesQueryable.removeSpatialQueryAcceleration();
}



/*
    Weightmap filter
*/


operator filterDartsByWMap<<< pointIndex >>>(
  io Ref<MeshScatterer> scatterer, GeometryLocationAttribute emitLocationAttr, Scalar maxSize, Scalar minSize
) {
  PolygonMesh mesh = scatterer.sourceMesh;
  ScalarAttribute wmapAttr = scatterer.weightmap.weightMapAttr;
  GeometryLocation emitLocation = emitLocationAttr.values[pointIndex];
  ScalarAttribute sizeAttr = scatterer.dartCandidates.getOrCreateSizesAttribute();
  Scalar normalized_size = mathext_reverseLinearInterpolate(minSize, maxSize, sizeAttr.values[pointIndex]);
  Scalar wmapValue = GetAttributeAtLocation(mesh, emitLocation, wmapAttr);

  if (normalized_size > wmapValue) {
    scatterer.dartCandidatesRemove[pointIndex] = true;
  }
}



object wmapSizeFilter : DartFilterer {
  defaultDartFilterer defaultFilter;
  
  Scalar maxSize;
  Scalar minSize;
};

function wmapSizeFilter() {
  this.minSize = 0.0f;
  this.maxSize = 1.0f;
  this.defaultFilter = defaultDartFilterer();
}

function wmapSizeFilter(Scalar maxSize, Scalar minSize) {
  this.maxSize = maxSize;
  this.minSize = minSize;
  this.defaultFilter = defaultDartFilterer();
}

function wmapSizeFilter.prefilter(io Ref<MeshScatterer> scatterer, UInt32 iteration) {
  scatterer.weightMapInitIfNeeded();

  GeometryAttributes attributes = scatterer.dartCandidates.getAttributes();
  GeometryLocationAttribute emitLocationAttr = attributes.getOrCreateGeometryLocationAttribute("emitLocation");

  filterDartsByWMap<<<scatterer.dartCandidates.size()>>>(scatterer, emitLocationAttr, this.maxSize, this.minSize);
}


function wmapSizeFilter.filterCandidates!(io Ref<MeshScatterer> scatterer, UInt32 iteration) {
  this.prefilter(scatterer, iteration);
  this.defaultFilter.filterCandidates(scatterer, iteration);
}

