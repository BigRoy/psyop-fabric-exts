require InlineDrawing;
require Math;

function InlineDrawing drawScatteredPoints(in Points points) { 

  GeometryAttributes attributes = points.getAttributes();
  ColorAttribute vertexColors = attributes.getOrCreateColorAttribute('vertexColors');
  Vec3Attribute normals = attributes.getOrCreateVec3Attribute('normals');

  InlineDrawing draw = OGLInlineDrawing_GetInstance();
  if(!draw.hasShader('OGLSurfaceVertexColorShader')) {
    InlineShader shader = draw.registerShader(OGLSurfaceVertexColorShader());
    InlineMaterial mat = shader.getOrCreateMaterial('debug');
  
    InlineShape shape = draw.getShape('debug');
    if(shape == null){
      shape = draw.registerShape(InlinePointsShape('debug', points).setPointSize(1.5));
    }
    mat.addInstance(SimpleInlineInstance('debug', draw.getRoot(), shape));
  }
  return draw;
}



operator drawSpheres(Points points, Scalar sizeFactor, Boolean easter) {

  GeometryAttributes attributes = points.getAttributes();
  ColorAttribute vertexColors = attributes.getOrCreateColorAttribute('vertexColors');
  Vec3Attribute normals = attributes.getOrCreateVec3Attribute('normals');

  InlineDrawing draw = OGLInlineDrawing_GetInstance();
  
  if(draw.getShapeCount() != 1) {
    PolygonMesh sphere = PolygonMesh();
    sphere.addSphere(Xfo(), 1.0, 3, true, false);
    draw.registerShape(InlineMeshShape('sphere', sphere));

    InlineShader phong = draw.registerShader(OGLSurfaceShader());
    InlineMaterial mat = phong.getOrCreateMaterial('mat');
  
    InlineTransform rootTfo = draw.getRoot();
    InlineTransform sphereTfo = rootTfo.addChild(StaticInlineTransform('spheresXfo'));

    InlineInstance sphereInstance = mat.addInstance(SimpleInlineInstance('sphereInst', sphereTfo, draw.getShape('sphere')));
  }

  InlineTransform rootTfo = draw.getRoot();
  InlineTransform sphereTfo = rootTfo.getChild('spheresXfo');
  InlineInstance sphereInstance = sphereTfo.getChild('sphereInst');
  
  Size count = points.size();
  sphereTfo.setLocalCount(count);
  
  
  for(Size i=0;i<count;i++) {
    Scalar radius = sizeFactor * points.getSize(i);
    Xfo sphere_xfo(
      points.getPosition(i), 
      Quat(), 
      Vec3(radius, radius, radius)
    );

    sphereTfo.setLocalXfo(i, sphere_xfo);
    
    if (easter) {

      Color color1, color2;
      color2.r = mathRandomScalar(20, i * 5) * 0.75 + 0.25;
      color2.g = mathRandomScalar(21, i * 6) * 0.75 + 0.25;
      color2.b = mathRandomScalar(22, i * 7) * 0.75 + 0.25;
      sphereInstance.setTransformUniform(InlineUniform('u_diffuseColor', color2), i);
      
    } else {
      sphereInstance.setTransformUniform(InlineUniform('u_diffuseColor', Color(0.0, 0.0, 0.0)), i);
    }
  }
}

operator drawSpheres(Points points, Scalar sizeFactor) {
  drawSpheres(points, sizeFactor, false);
}





object scattererDrawer {
    DrawingHandle handle;
};
 
function scattererDrawer.drawStuff!() {
  this.handle = DrawingHandle('DrawingHandle');

  if (this.handle){
    Xfo xfo(Vec3(0.0, 0.0, 20.0));
    drawXfo(this.handle.getRootTransform(), "Xfo", xfo);
    drawSphere ( this.handle.getRootTransform(), "sphere", xfo, 1.0, Color(0.0, 0.0, 0.0) );

  }
} 

function scattererDrawer.drawSpheres!(Points points_in) {
  this.handle = DrawingHandle('DrawingHandle');

  if (this.handle){
    for (UInt32 i = 0; i < points_in.size(); i++) {
      Xfo xfo(points_in.getPosition(i));
      Scalar radius = points_in.getSize(i);
      drawLinesSphere ( this.handle.getRootTransform(), "sphere_" + i, xfo, radius, Color(0.0, 0.0, 0.0) );
      
    }



  }
}